# BIER-query

Tomo Simeonov

##	Problem statement
The project’s goal is to create distributed browser based database with functionality similar to the standard server based database, but with better scaling and cost base. This will not be trivial low risk project as there are many existing problems that are not yet fully solved even for the standard databases, but also there will be new and unexpected ones from the unpredictable nature of browsers and their use.  A distributed hash table (DHT) will be used to create the backbone of the distributed database, the method on which route, store and retrieve decisions will be based, thus to allow more focus to be put on the more complex tasks and challenges. 
##	Technical challenges
The specifications of the project raise a variety of challenges that need to be address and overcome in order to get a successful project at the end. Challenges ranging from how the browsers will communicate with each other to how complex queries can be run in a DHT environment where most of the operations needed are not supported. Looking at the query layer there are a lot of uncertainties that need to be dealt with originating from the nature of the browsers, distributed systems and network connections. Even with current advances the browser is not a server and does not have its full functionality embedded. The DHT provides only the basic put and get semantics and more complex structure have to be mapped on top to support effectively the complex queries – joins, range, filters etc. Furthermore there are also the problems with the unpredictability of the system and the effects it will have on the query’s performance and accuracy.    
##	Approach to solution
The project will be divided into two parts, one to address issues with the queries and the other one to address issues with data storing and retrieval and communications. This paper will focus on the query part and will address the issues rising from the nature of the browsers and storage layer. A scalable search engine will be developed to support SQL-like expressions on top of the DHT layer, which will try to address many of the constrains previous projects in this area had. Key features of the new system will be the distributed index support and the ability to run distributed joins efficiently in the browser based unpredictable distributed environment.   
##	Technical background
The project will be written in the server-side language node. js, which is the preferred language for web development and can be run in the browsers using an open source project called browserify. Alongside the algorithms and code written specifically for the project a lot of open source projects will be used to achieve its goals while minimizing the risk and the time needed to deliver the project. At the beginning there will be some assumption made in order to put more focus on the hardest part of the project, leaving the more trivial bits for later on. For example the project initially will support only fraction of browsers as not all browsers, used to date, are up-to-date and support, off-the-shell, features required by the projects. An open sourced DHT based on Kademlia DHT will be used to provide the backbone of the system to minimize the risk of implementing a DHT from scratch.  Furthermore how the open sourced DHT is transformed to achieve the desired goals for the storage layer will not be discussed here and will be taken for granted. The query layer will be only aware of the public APIs the storage layer will expose to the world and not how they are implemented internally. For indexing data, an implementation using prefix hash table on top of distributed hash tables will be used, but the implementation will not be explored in details.  The database will support join queries as long as the join properties are indexed as otherwise the pressure put on the system will be too much and may damage the user experience too much.
##	Design
The next part of the paper will be divided in sections based on the type of querying functionality the database will support.
###i)	Selection queries 
The selection query will be used as the building block for all other queries supported by the database. The query will be able to get data spread across distance nodes. The data will be return in format defined by the schema and any data that does not have the same format should not be used.  The select query will support projection from start as this will allow the creation of light-weight queries will smaller impact on the network. Furthermore the filtering phase - where clause, will be executed on the local nodes only for the properties that do not have indexes, on the caller node for those that have.  For those that have index, the PHT will be interrogate, the resulting document ids will be used to minimize the impact on the database. The ids will be used in two ways, the first if there are no other properties to run filter on then a request for the documents will be executed. The second option will be valid only if there are non-indexed properties in the where clause then the query will be send only to the nodes where the ids are stored  to be executed and relevant data send back. For the case where there are no indexes for the properties used in the where clause the query will be send to all nodes.  
The functionality and performance of the query will be of great importance for the whole system and thus extra attention will put on it. There are some factors that will need to be taken into account when implementing the algorithm for the select as compare to the standard database there are some additional uncertainties. For example it can took longer to deliver data ( valid when there is timeout for the query) or the data is missing or is unreachable at the moment of the search and cannot be found ( valid when the query does not specify a wait time, but objects found wait).  There will be special properties in the where clause which will say how the query will finish – e.g. timeout or object count. For now the reserved properties will be BIER_TIME in seconds and BIER_OBJ. For the object count there will be internal timeout which will dictate when there is no more data and should finish even though it has not reach the end number. An effort will be made to minimize messages send through the network by the nodes. This will be achieved by combining responses from child nodes and sending them in one message.
###ii)	Aggregation functions
The aggregation query will be based on the select query and it will support aggregation functions maximum, minimum, average, count and sum.  The difference will be in the way the query is executed in the local nodes and caller when the filtering can be done all using the PHT. In the local nodes the aggregation function will be run for the local data and single value for it will be produced. At the caller side all local values received by the end time are combined according to the function provided, if the query request not just an aggregation query the whole data set has to be iterated over to update the values with the correct ones and then return to the user.  Compare to the simple select query this one cannot show data as it receives it from the other nodes, it has to wait, collect and process the data to be able to show the correct value for the function.  Here key problem will be when to show the data as there will be timeout for the query after which the query should not run and take resources. 
###iii)	Join queries
The most complex part of the whole query layer of the database will be to achieve efficient distributed join queries.  The execution of join queries will take a lot of local and network resources and thus developer should not use them without thinking about the repercussions. The way the join query will be executed is different from the way select and aggregation queries are executed, but it will be based heavily on them.  Furthermore the supported join queries will be inner, full left and right on only two tables as the amount of work the database will have to do to achieve joining on more than two will be too much to handle by the browsers.  The full right join will be transformed into full left join as there are similar and it will be more efficient if the database focus on less joins.  The query will be executed by first sending the query to all nodes.  Secondly the nodes will filter their local data for the left table. After that if there is data that matches the filter, a special select will be executed for the matching data from the right table.  For this select a new where clause will be devised in order to get the right data send to the node.  Here far greater performance will be achieved if the table property has an index on it, if not the whole database will slow due to the volume of message exchange and computation done across the system, this is why a join query will be allow only on properties that have indexes.
